grid1 = [
    [1, 0, 4, 2],
    [4, 2, 1, 3],
    [2, 1, 3, 4],
    [3, 4, 2, 1]]

grid2 = [
    [1, 0, 4, 2],
    [4, 2, 1, 3],
    [2, 1, 0, 4],
    [3, 4, 2, 1]]

grid3 = [
    [1, 0, 4, 2],
    [4, 2, 1, 0],
    [2, 1, 0, 4],
    [0, 4, 2, 1]]

grid4 = [
    [1, 0, 4, 2],
    [0, 2, 1, 0],
    [2, 1, 0, 4],
    [0, 4, 2, 1]]

grid5 = [
    [1, 0, 0, 2],
    [0, 0, 1, 0],
    [0, 1, 0, 4],
    [0, 0, 0, 1]]

grid6 = [
    [0, 0, 6, 0, 0, 3],
    [5, 0, 0, 0, 0, 0],
    [0, 1, 3, 4, 0, 0],
    [0, 0, 0, 0, 0, 6],
    [0, 0, 1, 0, 0, 0],
    [0, 5, 0, 0, 6, 4]]
grid7_easy=[[9, 0, 6, 0, 0, 1, 0, 4, 0],
[7, 0, 1, 2, 9, 0, 0, 6, 0],
[4, 0, 2, 8, 0, 6, 3, 0, 0],
[0, 0, 0, 0, 2, 0, 9, 8, 0],
[6, 0, 0, 0, 0, 0, 0, 0, 2],
[0, 9, 4, 0, 8, 0, 0, 0, 0],
[0, 0, 3, 7, 0, 8, 4, 0, 9],
[0, 4, 0, 0, 1, 3, 7, 0, 6],
[0, 6, 0, 9, 0, 0, 1, 0, 8]]
grid8_easy=[[0, 0, 0, 2, 6, 0, 7, 0, 1],
[6, 8, 0, 0, 7, 0, 0, 9, 0],
[1, 9, 0, 0, 0, 4, 5, 0, 0],
[8, 2, 0, 1, 0, 0, 0, 4, 0],
[0, 0, 4, 6, 0, 2, 9, 0, 0],
[0, 5, 0, 0, 0, 3, 0, 2, 8],
[0, 0, 9, 3, 0, 0, 0, 7, 4],
[0, 4, 0, 0, 5, 0, 0, 3, 6],
[7, 0, 3, 0, 1, 8, 0, 0, 0]]
grid9_easy=[[0, 3, 0, 4, 0, 0],
[0, 0, 5, 6, 0, 3],
[0, 0, 0, 1, 0, 0],
[0, 1, 0, 3, 0, 5],
[0, 6, 4, 0, 3, 1],
[0, 0, 1, 0, 4, 6]]
grid10_mid=[[0, 0, 0, 6, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 5, 0, 1],
[3, 6, 9, 0, 8, 0, 4, 0, 0],
[0, 0, 0, 0, 0, 6, 8, 0, 0],
[0, 0, 0, 1, 3, 0, 0, 0, 9],
[4, 0, 5, 0, 0, 9, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 3, 0, 0],
[0, 0, 6, 0, 0, 7, 0, 0, 0],
[1, 0, 0, 3, 4, 0, 0, 0, 0]]
grid11_mid=[[8, 0, 9, 0, 2, 0, 3, 0, 0],
[0, 3, 7, 0, 6, 0, 5, 0, 0],
[0, 0, 0, 4, 0, 9, 7, 0, 0],
[0, 0, 2, 9, 0, 1, 0, 6, 0],
[1, 0, 0, 3, 0, 6, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 1, 0, 3],
[7, 0, 0, 0, 0, 0, 0, 0, 8],
[5, 0, 0, 0, 0, 0, 0, 1, 4],
[0, 0, 0, 2, 8, 4, 6, 0, 5]]
grid12_hard=[[0, 2, 0, 0, 0, 0, 0, 1, 0],
[0, 0, 6, 0, 4, 0, 0, 0, 0],
[5, 8, 0, 0, 9, 0, 0, 0, 3],
[0, 0, 0, 0, 0, 3, 0, 0, 4],
[4, 1, 0, 0, 8, 0, 6, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 9, 5],
[2, 0, 0, 0, 1, 0, 0, 8, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 3, 1, 0, 0, 8, 0, 5, 7]]

grid7 = [
		[9, 0, 6, 0, 0, 1, 0, 4, 0],
		[7, 0, 1, 2, 9, 0, 0, 6, 0],
		[4, 0, 2, 8, 0, 6, 3, 0, 0],
		[0, 0, 0, 0, 2, 0, 9, 8, 0],
		[6, 0, 0, 0, 0, 0, 0, 0, 2],
		[0, 9, 4, 0, 8, 0, 0, 0, 0],
		[0, 0, 3, 7, 0, 8, 4, 0, 9],
		[0, 4, 0, 0, 1, 3, 7, 0, 6],
		[0, 6, 0, 9, 0, 0, 1, 0, 8]]

grid8 = [
		[0, 2, 0, 0, 0, 0, 0, 1, 0],
		[0, 0, 6, 0, 4, 0, 0, 0, 0],
		[5, 8, 0, 0, 9, 0, 0, 0, 3],
		[0, 0, 0, 0, 0, 3, 0, 0, 4],
		[4, 1, 0, 0, 8, 0, 6, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 9, 5],
		[2, 0, 0, 0, 1, 0, 0, 8, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 3, 1, 0, 0, 8, 0, 5, 7]]


def check_solution(grid):
    for i in range(len(grid)):  # this for loop return the fiewset possipility
        ro = grid[i]

        for j in range(len(ro)):
            if type(grid[i][j])==list:
                return False
    return True
def the_missing_numbers(grid, n_cols, n_rows, which_row, which_coulm):
    '''the arguemnts are grid=the grid we need to solve,
    n_cols and n_rows=the number of colums and rows in each sequare in the grid,
     which_reow and which_coulm= the colum and row the 0 in(location of 0),
    this function will be called in find empty function to select the empty location with the fewest number of variable options to fill'''
    numbers_list = []#list to collect numbers that can not be added to the empty(0)
    for i in range(n_cols):#collecting numbers in the same sequare
        rows = (i * n_rows, (i + 1) * n_rows)
        for j in range(n_rows):
            cols = (j * n_cols, (j + 1) * n_cols)
            square = []
            for k in range(rows[0], rows[1]):
                line = grid[k][cols[0]:cols[1]]
                square += line
            if which_coulm in range(cols[0], cols[1]) and which_row in range(rows[0], rows[1]):
                for i in square:
                    if i !=0 and type(i)!=list :
                        numbers_list.append(i)  # add the numbers of the square
    for i in grid[which_row]:#collecting numbers in the same row
        if i != 0 and type(i)!=list:
            numbers_list.append(i)  # add the numbers in the row
    for i in range(0, n_cols * n_rows):#collecting numbers in the same colum
        colum_number = grid[i][which_coulm]
        if colum_number!=0 and type(colum_number)!=list:
            numbers_list.append(colum_number)  # add the numbers in the same colum

    all_numbers=[*range(1,n_cols*n_rows+1)]#all numbers that can be added to the soduco
    all_numbers=set(all_numbers)
    possiple_numbers=all_numbers.symmetric_difference(set(numbers_list))#all possiple numbers that can be added to the empety space(0)
    return list(possiple_numbers)


def adding_lists(grid,col,row):
    for i in range(len(grid)):  # this for loop return the fiewset possipility
        ro = grid[i]

        for j in range(len(ro)):
            if grid[i][j] == 0:
                b=the_missing_numbers(grid,col,row,i,j)
                grid[i][j]=b
    return grid
def filling_in(grid):
    listt=[]
    for i in range(len(grid)):
        l=grid[i]
        for j in range(len(grid)):
              if type(grid[i][j])==list :
                  listt.append(len(grid[i][j]))
    for i in range(len(grid)):
        l = grid[i]
        for j in range(len(l)):
             if type(grid[i][j]) == list and len(grid[i][j]) ==min(listt):
                 for n in grid[i][j]:
                    grid[i][j] = n
                    return [grid, i, j, n]


def after_(grid,n_rows,n_cols,whichrow,whichcoulm,n):
    numbers_list = []#list to collect numbers that can not be added to the empty(0)

    for i in range(n_cols):#collecting numbers in the same sequare
        rows = (i * n_rows, (i + 1) * n_rows)
        for j in range(n_rows):
            cols = (j * n_cols, (j + 1) * n_cols)
            square = []
            for k in range(rows[0], rows[1]):
                line = grid[k][cols[0]:cols[1]]
                square += line
            if whichcoulm in range(cols[0], cols[1]) and whichrow in range(rows[0], rows[1]):
                for i in square:
                    if type(i)==list :
                        for mama in i:
                            if mama==n:
                                i.remove(n) # add the numbers of the square
    for i in grid[whichrow]:#collecting numbers in the same row
        if type(i)==list:
            for mama in i:
                if mama==n:
                    i.remove(n)  # add the numbers in the row
    for i in range(0, n_cols * n_rows):#collecting numbers in the same colum
        colum_number = grid[i][whichcoulm]
        if type(colum_number)==list:
            for nona in colum_number:
                if nona == n:
                    colum_number.remove(n)# add the numbers in the same colum
    return grid
# while filling_in(gega):
#     gega=filling_in(gega)
#     whichrow=filling_in(gega)[1]
#     whichcolum=filling_in(gega)[2]
#     n=filling_in(gega)[3]
#     gega=after_(gega,3,3,whichrow,whichcolum,n)
#     j+=1
def after(grid,n_rows,n_cols):
    h=filling_in(grid)
    hoha = grid
    if h :
        hoha=after_(h[0],n_rows,n_cols,h[1],h[2],h[3])

    return hoha
def solve(grid, n_col,n_row):
    grid=adding_lists(grid,n_col,n_row)
    while not check_solution(grid):
        grid=after(grid,n_row,n_col)
    return grid
def check_section(section, n):
    if len(set(section)) == len(section) and sum(section) == sum([i for i in range(n + 1)]):
        return True
    return False


def get_squares(grid, n_rows, n_cols):
    squares = []
    for i in range(n_cols):
        rows = (i * n_rows, (i + 1) * n_rows)
        for j in range(n_rows):
            cols = (j * n_cols, (j + 1) * n_cols)
            square = []
            for k in range(rows[0], rows[1]):
                line = grid[k][cols[0]:cols[1]]
                square += line
            squares.append(square)

    return squares


# To complete the first assignment, please write the code for the following function
def check_final_solution(grid, n_rows, n_cols):
    '''
	This function is used to check whether a sudoku board has been correctly solved
	args: grid - representation of a suduko board as a nested list.
	returns: True (correct solution) or False (incorrect solution)
	'''
    n = n_rows * n_cols

    for row in grid:
        if check_section(row, n) == False:
            return False

    for i in range(n_rows ** 2):
        column = []
        for row in grid:
            column.append(row[i])

        if check_section(column, n) == False:
            return False

    squares = get_squares(grid, n_rows, n_cols)
    for square in squares:
        if check_section(square, n) == False:
            return False

    return True

grid1s=solve(grid1,2,2)
print(check_final_solution(grid1s,2,2))
grid2s=solve(grid2,2,2)
def check_section(section, n):
    if len(set(section)) == len(section) and sum(section) == sum([i for i in range(n + 1)]):
        return True
    return False


def get_squares(grid, n_rows, n_cols):
    squares = []
    for i in range(n_cols):
        rows = (i * n_rows, (i + 1) * n_rows)
        for j in range(n_rows):
            cols = (j * n_cols, (j + 1) * n_cols)
            square = []
            for k in range(rows[0], rows[1]):
                line = grid[k][cols[0]:cols[1]]
                square += line
            squares.append(square)

    return squares


# To complete the first assignment, please write the code for the following function
def check_final_solution(grid, n_rows, n_cols):
    '''
	This function is used to check whether a sudoku board has been correctly solved
	args: grid - representation of a suduko board as a nested list.
	returns: True (correct solution) or False (incorrect solution)
	'''
    n = n_rows * n_cols

    for row in grid:
        if check_section(row, n) == False:
            return False

    for i in range(n_rows ** 2):
        column = []
        for row in grid:
            column.append(row[i])

        if check_section(column, n) == False:
            return False

    squares = get_squares(grid, n_rows, n_cols)
    for square in squares:
        if check_section(square, n) == False:
            return False

    return True

grid3s=solve(grid3,2,2)
grid4s=solve(grid4,2,2)
grid5s=solve(grid5,2,2)
grid6s=solve(grid6,3,2)
grid7s=solve(grid7,3,3)
grid8s=solve(grid8,3,3)
print(grid8s)
print(check_final_solution(grid3s,2,2))
print(check_final_solution(grid4s,2,2))
print(check_final_solution(grid5s,2,2))
print(check_final_solution(grid6s,2,3))
print(check_final_solution(grid7s,3,3))
print(check_final_solution(grid8s,3,3))